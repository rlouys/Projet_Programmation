characters.c

/*---------------------------------------------------------------------*/

/**
* Retourne la taille de la Liste
* @param li La liste
* @return Le nombre d'élements de la Liste
*/
int list_length(List li)
{
	int size = 0;

	if(is_empty_list(li))
		return size;

	while(li != NULL)
	{
		size++;
		li = li->next;
	}

	return size;
}

// ---------------------------------------------------------------------- // 

	printf("Nombre d'éléments : %d\n", list_length(ally));




// ---------------------------------------------------------------------- // 

/*---------------------------------------------------------------------*/

List push_front_list_scanf(List li)
{
	Ally *element;

	element = malloc(sizeof(*element));

	if(element == NULL)
	{
		fprintf(stderr, "Erreur : probleme allocation dynamique.\n");
		exit(EXIT_FAILURE);
	}

	printf("Entrez un chiffre (début de liste): ");
	scanf("%d", &element->health);


	if(is_empty_list(li))
		element->next = NULL;
	else
		element->next = li;

	return element;
}
*---------------------------------------------------------------------*/

/**
* Ajoute un entier en fin de Liste
* @param li La liste
* @param x L'entier à insérer
* @return La liste avec le nouvel élement ajouté
*/
List push_back_list(List li, int x)
{
	Ally *element;

	element = malloc(sizeof(*element));

	if(element == NULL)
	{
		fprintf(stderr, "Erreur : probleme allocation dynamique.\n");
		exit(EXIT_FAILURE);
	}

	element->health = x;// ------------------------------------------------------------------ //

/*void Display()
{	
	glClearColor(0.0f,0.0f0

    glPushMatrix();
    glTranslatef(xPos, yPos, 0);

    HeroCharacter(direction); // génère le perso
    updatePos(direction); // permet le déplacement

    glPopMatrix();
    glFlush();
    tick++;

}*/

// ------------------------------------------------------------------ //


/*void WelcomeDisplay()
{	

	glClearColor(0.0f,0.0f,0.0f,0.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    //drawWall(mX, mY);

    glColor3f(1, 0, 0);

    glRasterPos3f(50, 500, 1);
    char msg1[]="SUSTAINABLE MOBILITY : SUBSISTANCE";
    for(int i = 0; i <strlen(msg1);i++)
    	glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, msg1[i]);

    glRasterPos3f(50, 480, 1);
    char msg2[]="----------------------------------------------------";
    for(int i = 0; i <strlen(msg2);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg2[i]);

    glRasterPos3f(50, 400, 0);
    char msg3[]="CONTINUER ('c')";
    for(int i = 0; i <strlen(msg3);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg3[i]);

    glRasterPos3f(50, 375, 0);
    char msg4[]="Nouvelle partie ('n')";
    for(int i = 0; i <strlen(msg4);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg4[i]);

    glRasterPos3f(50, 300, 0);
    char msg5[]="GAMEPLAY ('g')";
    for(int i = 0; i <strlen(msg5);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg5[i]);

    glRasterPos3f(50, 275, 0);
    char msg6[]="OPTIONS ('o')";
    for(int i = 0; i <strlen(msg6);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg6[i]);

    glRasterPos3f(50, 250, 0);
    char msg7[]="Sortie('x')";
    for(int i = 0; i <strlen(msg7);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg7[i]);

    glRasterPos3f(50, 50, 0);
    char msg8[]="Press 'c' to enter the game";
    for(int i = 0; i <strlen(msg8);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg8[i]);

    glutSwapBuffers();
}*/

// ------------------------------------------------------------------ //

/*void DisplayOptions()
{	


	glClearColor(0.0f,0.0f,0.0f,0.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    //drawWall(mX, mY);

    glColor3f(1, 0, 0);

    glRasterPos3f(50, 500, 1);
    char msg1[]="OPTIONS";
    for(int i = 0; i <strlen(msg1);i++)
    	glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, msg1[i]);

    glRasterPos3f(50, 480, 1);
    char msg2[]="------------";
    for(int i = 0; i <strlen(msg2);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg2[i]);

    glRasterPos3f(50, 400, 0);
    char msg3[]="LOREM IPSUM (...)";
    for(int i = 0; i <strlen(msg3);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg3[i]);

    
    glutSwapBuffers();
}*/
// ------------------------------------------------------------------ //

/*void DisplayGameplay()
{	
	glClearColor(0.0f,0.0f,0.0f,0.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    //drawWall(mX, mY);

    glColor3f(1, 0, 0);

    glRasterPos3f(50, 500, 1);
    char msg1[]="GAMEPLAY";
    for(int i = 0; i <strlen(msg1);i++)
    	glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, msg1[i]);

    glRasterPos3f(50, 480, 1);
    char msg2[]="---------------";
    for(int i = 0; i <strlen(msg2);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg2[i]);

    glRasterPos3f(50, 400, 0);
    char msg3[]="LOREM IPSUM (...)";
    for(int i = 0; i <strlen(msg3);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg3[i]);

    
    glutSwapBuffers();
}*/

// ------------------------------------------------------------------ //


// ------------------------------------------------------------------ //

/*void DisplayEnding()
{	
	glClearColor(0.0f,0.0f,0.0f,0.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    //drawWall(mX, mY);

    glColor3f(1, 0, 0);

    glRasterPos3f(50, 500, 1);
    char msg1[]="CYA";
    for(int i = 0; i <strlen(msg1);i++)
    	glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, msg1[i]);

    glRasterPos3f(50, 480, 1);
    char msg2[]="-----------------";
    for(int i = 0; i <strlen(msg2);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg2[i]);

    glRasterPos3f(50, 400, 0);
    char msg3[]="CREDITS (...)";
    for(int i = 0; i <strlen(msg3);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg3[i]);

    
    glutSwapBuffers();
}*/

// ------------------------------------------------------------------ //

/*void myMenu(int id){
	switch(id){

		case 2:
			printf("Options\n");
			break;
		case 3:
			printf("Gameplay\n");
			break;
		case 4:
			printf("Pause\n");	
			break;
		case 5:
			printf("_!_Cheat_mode_!_");	
		case 6:
			printf("Cya!");	
	}
}*/

// ------------------------------------------------------------------ //

	if(is_empty_list(li))
		return element;

	Ally *temp;
	temp = li;

	while(temp->next != NULL)
		temp = temp->next;

	temp->next = element;

	return li;
}

/*---------------------------------------------------------------------*/

/**
* Ajoute un entier en début de Liste
* @param li La liste
* @param x L'entier à insérer
* @return La liste avec le nouvel élement ajouté
*/
List push_front_list(List li, int x)
{
	Ally *element;

	element = malloc(sizeof(*element));

	if(element == NULL)
	{
		fprintf(stderr, "Erreur : probleme allocation dynamique.\n");
		exit(EXIT_FAILURE);
	}

	element->health = x;

	if(is_empty_list(li))
		element->next = NULL;
	else
		element->next = li;

	return element;
}
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 


main.c

/*ally = push_front_list(ally, 36);
	print_character(ally);

	ally = push_front_list(ally, 87);
	ally = push_front_list_scanf(ally);
		print_character(ally);

	ally = push_front_list_scanf(ally);
	print_character(ally);
	ally = push_front_list_scanf(ally);
	print_character(ally);*/


main.c
-------------



 case 'c':
		glutDisplayFunc(Display);
		break;
	case 'n':
		glutDisplayFunc(Display);
		break;
	case 'x':
		glutDisplayFunc(DisplayEnding);
		break;
	case 'g':
		glutDisplayFunc(DisplayGameplay);
		break;
	case 'o':
		glutDisplayFunc(DisplayOptions);		
		break;	    
	case 'm':
		glutDisplayFunc(WelcomeDisplay);	
    };






characters.h


List push_back_list(List li, int x);


// ---------------------------------------------------------------------- // 

	List push_front_list_scanf(List li);

// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 
// ---------------------------------------------------------------------- // 

List push_front_list(List li, int x);

// ------------------------------------------------------------------ //

/*void Display()
{	
	glClearColor(0.0f,0.0f0

    glPushMatrix();
    glTranslatef(xPos, yPos, 0);

    HeroCharacter(direction); // génère le perso
    updatePos(direction); // permet le déplacement

    glPopMatrix();
    glFlush();
    tick++;

}*/

// ------------------------------------------------------------------ //


/*void WelcomeDisplay()
{	

	glClearColor(0.0f,0.0f,0.0f,0.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    //drawWall(mX, mY);

    glColor3f(1, 0, 0);

    glRasterPos3f(50, 500, 1);
    char msg1[]="SUSTAINABLE MOBILITY : SUBSISTANCE";
    for(int i = 0; i <strlen(msg1);i++)
    	glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, msg1[i]);

    glRasterPos3f(50, 480, 1);
    char msg2[]="----------------------------------------------------";
    for(int i = 0; i <strlen(msg2);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg2[i]);

    glRasterPos3f(50, 400, 0);
    char msg3[]="CONTINUER ('c')";
    for(int i = 0; i <strlen(msg3);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg3[i]);

    glRasterPos3f(50, 375, 0);
    char msg4[]="Nouvelle partie ('n')";
    for(int i = 0; i <strlen(msg4);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg4[i]);

    glRasterPos3f(50, 300, 0);
    char msg5[]="GAMEPLAY ('g')";
    for(int i = 0; i <strlen(msg5);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg5[i]);

    glRasterPos3f(50, 275, 0);
    char msg6[]="OPTIONS ('o')";
    for(int i = 0; i <strlen(msg6);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg6[i]);

    glRasterPos3f(50, 250, 0);
    char msg7[]="Sortie('x')";
    for(int i = 0; i <strlen(msg7);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg7[i]);

    glRasterPos3f(50, 50, 0);
    char msg8[]="Press 'c' to enter the game";
    for(int i = 0; i <strlen(msg8);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg8[i]);

    glutSwapBuffers();
}*/

// ------------------------------------------------------------------ //

/*void DisplayOptions()
{	


	glClearColor(0.0f,0.0f,0.0f,0.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    //drawWall(mX, mY);

    glColor3f(1, 0, 0);

    glRasterPos3f(50, 500, 1);
    char msg1[]="OPTIONS";
    for(int i = 0; i <strlen(msg1);i++)
    	glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, msg1[i]);

    glRasterPos3f(50, 480, 1);
    char msg2[]="------------";
    for(int i = 0; i <strlen(msg2);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg2[i]);

    glRasterPos3f(50, 400, 0);
    char msg3[]="LOREM IPSUM (...)";
    for(int i = 0; i <strlen(msg3);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg3[i]);

    
    glutSwapBuffers();
}*/
// ------------------------------------------------------------------ //

/*void DisplayGameplay()
{	
	glClearColor(0.0f,0.0f,0.0f,0.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    //drawWall(mX, mY);

    glColor3f(1, 0, 0);

    glRasterPos3f(50, 500, 1);
    char msg1[]="GAMEPLAY";
    for(int i = 0; i <strlen(msg1);i++)
    	glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, msg1[i]);

    glRasterPos3f(50, 480, 1);
    char msg2[]="---------------";
    for(int i = 0; i <strlen(msg2);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg2[i]);

    glRasterPos3f(50, 400, 0);
    char msg3[]="LOREM IPSUM (...)";
    for(int i = 0; i <strlen(msg3);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg3[i]);

    
    glutSwapBuffers();
}*/

// ------------------------------------------------------------------ //


// ------------------------------------------------------------------ //

/*void DisplayEnding()
{	
	glClearColor(0.0f,0.0f,0.0f,0.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    //drawWall(mX, mY);

    glColor3f(1, 0, 0);

    glRasterPos3f(50, 500, 1);
    char msg1[]="CYA";
    for(int i = 0; i <strlen(msg1);i++)
    	glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, msg1[i]);

    glRasterPos3f(50, 480, 1);
    char msg2[]="-----------------";
    for(int i = 0; i <strlen(msg2);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg2[i]);

    glRasterPos3f(50, 400, 0);
    char msg3[]="CREDITS (...)";
    for(int i = 0; i <strlen(msg3);i++)
    	glutBitmapCharacter(GLUT_BITMAP_9_BY_15, msg3[i]);

    
    glutSwapBuffers();
}*/

// ------------------------------------------------------------------ //

/*void myMenu(int id){
	switch(id){

		case 2:
			printf("Options\n");
			break;
		case 3:
			printf("Gameplay\n");
			break;
		case 4:
			printf("Pause\n");	
			break;
		case 5:
			printf("_!_Cheat_mode_!_");	
		case 6:
			printf("Cya!");	
	}
}*/

// ------------------------------------------------------------------ //












OLD drawWall

for (int j = 0; j < mX; ++j)
	{
		for (int i = 0; i < mY+1; i++)
		{
			if(*(*(map + j) + i) == '#')
			{	



				//glColor3f(1.0f,1.0f,1.0f);

				glMatrixMode(GL_MODELVIEW);
				glLoadIdentity();
				//glTranslatef(i,j,0.0f);
				//glTranslatef(j*Square_size,i*Square_size,0.0f);

				glBegin(GL_QUADS);
				glColor3f(0.30,0.23,0.12);
				glVertex2d(i*(1000/mY),j*(1000/mX));
				glVertex2d((i+1)*(1000/mY),j*(1000/mX));
				glVertex2d((i+1)*(1000/mY),(j+1)*(1000/mX));
				glVertex2d(i*(1000/mY), (j+1)*(1000/mX));
			
				glEnd();

			/*	glBegin(GL_POLYGON);         //draw road
				glColor3f(0.5,0.5,0.5);
				glVertex3f(0,15, 0.0f);
				glVertex3f(50, 15, 0.0f);
				glVertex3f(mX*Square_size, 15, 0.0f);
				glVertex3f(0, mY*Square_size, 0.0f);
				glEnd();*/
			
			}

			if(*(*(map + j) + i) == '1')
			{	



				//glColor3f(0.0f,0.0f,0.0f);

				glMatrixMode(GL_MODELVIEW);
				glLoadIdentity();
			//	glTranslatef(j,i,0.0f);
				//glTranslatef(j*Square_size,i*Square_size,0.0f);

				/*//glColor3f(1.0,1.0,0.0);
				glVertex3f(0.0f, 0.0f, 0.0f);
				glVertex3f(Square_size, 0.0f, 0.0f);
				glVertex3f(Square_size,Square_size, 0.0f);
				glVertex3f(0.0f,Square_size, 0.0f);*/

				glBegin(GL_QUADS);
				glColor3f(0.94,0.87,0.70);
				glVertex2d(i*(1000/mY),j*(1000/mX));
				glVertex2d((i+1)*(1000/mY),j*(1000/mX));
				glVertex2d((i+1)*(1000/mY),(j+1)*(1000/mX));
				glVertex2d(i*(1000/mY), (j+1)*(1000/mX));
			
				glEnd();

			/*
				glBegin(GL_POLYGON);         //draw road
				glColor3f(0.5,0.5,0.5);
				glVertex3f(0,15, 0.0f);
				glVertex3f(50, 15, 0.0f);
				glVertex3f(mX*Square_size, 15, 0.0f);
				glVertex3f(0, mY*Square_size, 0.0f);
				glEnd();*/
			
			}
		
			if (*(*(map + j) + i) == '|')
			{
			//	glColor3f(1.0f,1.0f,0.0f);

				glMatrixMode(GL_MODELVIEW);
				glLoadIdentity();
				//glTranslatef(i,j,0.0f);
				//glTranslatef(j*Square_size, i*Square_size,0.0f);

				/*glVertex3f(0.0f, 0.0f, 0.0f);
				glVertex3f(Square_size/4, 0.0f, 0.0f);
				glVertex3f(Square_size/4,Square_size, 0.0f);
				glVertex3f(0.0f,Square_size, 0.0f);*/

				glBegin(GL_QUADS);
				glColor3f(1.0,1.0,1.0);
				glVertex2d(i*(1000/mY),j*(1000/mX));
				glVertex2d((i+0.5)*(1000/mY),j*(1000/mX));
				glVertex2d((i+0.5)*(1000/mY),(j+1)*(1000/mX));
				glVertex2d(i*(1000/mY), (j+1)*(1000/mX));
				glEnd();

				glBegin(GL_QUADS);
				glColor3f(0.5,0.5,0.5);
				glVertex2d((i+0.5)*(1000/mY),j*(1000/mX));
				glVertex2d((i+1)*(1000/mY),j*(1000/mX));
				glVertex2d((i+1)*(1000/mY),(j+1)*(1000/mX));
				glVertex2d((i+0.5)*(1000/mY), (j+1)*(1000/mX));
				glEnd();
			}

			if (*(*(map + j) + i) == 'l')
			{
			//	glColor3f(1.0f,1.0f,0.0f);

				glMatrixMode(GL_MODELVIEW);
				glLoadIdentity();
				//glTranslatef(i,j,0.0f);
				//glTranslatef(j*Square_size, i*Square_size,0.0f);

				/*glVertex3f(0.0f, 0.0f, 0.0f);
				glVertex3f(Square_size/4, 0.0f, 0.0f);
				glVertex3f(Square_size/4,Square_size, 0.0f);
				glVertex3f(0.0f,Square_size, 0.0f);*/

				glBegin(GL_QUADS);
				glColor3f(1.0,1.0,0.70);
				glVertex2d(i*(1000/mY),j*(1000/mX));
				glVertex2d((i+0.5)*(1000/mY),j*(1000/mX));
				glVertex2d((i+0.5)*(1000/mY),(j+1)*(1000/mX));
				glVertex2d(i*(1000/mY), (j+1)*(1000/mX));
				glEnd();

				glBegin(GL_QUADS);
				glColor3f(0.5,0.5,0.5);
				glVertex2d((i+0.5)*(1000/mY),j*(1000/mX));
				glVertex2d((i+1)*(1000/mY),j*(1000/mX));
				glVertex2d((i+1)*(1000/mY),(j+1)*(1000/mX));
				glVertex2d((i+0.5)*(1000/mY), (j+1)*(1000/mX));
				glEnd();
			}

			if(*(*(map + j) + i) == 'e')
			{
//				glColor3f(0.0f,0.0f,0.0f);

				glMatrixMode(GL_MODELVIEW);
				glLoadIdentity();
			//	glTranslatef(j,i,0.0f);
				//glTranslatef(j*Square_size,i*Square_size,0.0f);

				//glColor3f(1.0,1.0,0.0);
				/*glVertex3f(0.0f, 0.0f, 0.0f);
				glVertex3f(Square_size, 0.0f, 0.0f);
				glVertex3f(Square_size,Square_size, 0.0f);
				glVertex3f(0.0f,Square_size, 0.0f);*/

				glBegin(GL_QUADS);
				glColor3f(1.0,1.0,1.0);
				glVertex2d(i*(1000/mY),j*(1000/mX));
				glVertex2d((i+1)*(1000/mY),j*(1000/mX));
				glVertex2d((i+1)*(1000/mY),(j+1)*(1000/mX));
				glVertex2d(i*(1000/mY), (j+1)*(1000/mX));
			
				glEnd();


				
		/*		glBegin(GL_POLYGON);         //draw road
				glColor3f(0.5,0.5,0.5);
				glVertex3f(0,15, 0.0f);
				glVertex3f(50, 15, 0.0f);
				glVertex3f(mX*Square_size, 15, 0.0f);
				glVertex3f(0, mY*Square_size, 0.0f);
				glEnd();*/
			}

			if(*(*(map + j) + i) == ' ')
			{

				glMatrixMode(GL_MODELVIEW);
				glLoadIdentity();
			//	glTranslatef(j,i,0.0f);
				//glTranslatef(j*Square_size,i*Square_size,0.0f);

				//glColor3f(1.0,1.0,0.0);
			/*	glVertex3f(0.0f, 0.0f, 0.0f);
				glVertex3f(Square_size, 0.0f, 0.0f);
				glVertex3f(Square_size,Square_size, 0.0f);
				glVertex3f(0.0f,Square_size, 0.0f);*/

				glBegin(GL_QUADS);
				glColor3f(0.5f, 0.5f,0.5f);
				glVertex2d(i*(1000/mY),j*(1000/mX));
				glVertex2d((i+1)*(1000/mY),j*(1000/mX));
				glVertex2d((i+1)*(1000/mY),(j+1)*(1000/mX));
				glVertex2d(i*(1000/mY), (j+1)*(1000/mX));
			
				glEnd();

			}	

			if(*(*(map + j) + i) == 'z')
			{
	//			glColor3f(0.0f,0.0f,0.0f);

				glMatrixMode(GL_MODELVIEW);
				glLoadIdentity();
			//	glTranslatef(j,i,0.0f);
				//glTranslatef(j*Square_size,i*Square_size,0.0f);

				//glBegin(GL_QUADS);
				/*glColor3f(0.5,0.5,0.5);
				glVertex3f(0.0f, 0.0f, 0.0f);
				glVertex3f(Square_size, 0.0f, 0.0f);
				glVertex3f(Square_size,Square_size, 0.0f);
				glVertex3f(0.0f,Square_size, 0.0f);*/

				glBegin(GL_QUADS);
				glColor3f(0.5,0.5,0.5);
				glVertex2d(i*(1000/mY),j*(1000/mX));
				glVertex2d((i+1)*(1000/mY),j*(1000/mX));
				glVertex2d((i+1)*(1000/mY),(j+1)*(1000/mX));
				glVertex2d(i*(1000/mY), (j+1)*(1000/mX));
			
				glEnd();
				
			}
			
			if(*(*(map + j) + i) == 'b')
			{
		//		glColor3f(1.0f,1.0f,1.0f);

				glMatrixMode(GL_MODELVIEW);
				glLoadIdentity();
				//glTranslatef(i*Square_size,j*Square_size,0.0f);
				glTranslatef(j,i,0.0f);

				/*glBegin(GL_QUADS);
				//glColor3f(1.0,1.0,0.0);
				glVertex3f(0.0f, 0.0f, 0.0f);
				glVertex3f(Square_size, 0.0f, 0.0f);
				glVertex3f(Square_size,Square_size, 0.0f);
				glVertex3f(0.0f,Square_size, 0.0f);*/

				glBegin(GL_QUADS);
				glColor3f(1.0,1.0,0.0);
				glVertex2d(i*(1000/mY),j*(1000/mX));
				glVertex2d((i+1)*(1000/mY),j*(1000/mX));
				glVertex2d((i+1)*(1000/mY),(j+1)*(1000/mX));
				glVertex2d(i*(1000/mY), (j+1)*(1000/mX));
			
				glEnd();

				
			/*	glBegin(GL_POLYGON);         //draw road
				glColor3f(0.5,0.5,0.5);
				glVertex3f(0,15, 0.0f);
				glVertex3f(50, 15, 0.0f);
				glVertex3f(mX*Square_size, 15, 0.0f);
				glVertex3f(0, mY*Square_size, 0.0f);
				glEnd();*/
			}

		}
	}

	

}


/*

// --------------------------------------------------------------------- //

List new_character(void)
{
	return NULL;
}

// --------------------------------------------------------------------- //


bool is_empty_list(List li)
{
	if(li == NULL)
		return true;

	return false;
}

// --------------------------------------------------------------------- //

void print_character(List Hero)
{
	if(is_empty_list(Hero))
	{
		printf("Rien a afficher, il n'y a pas Hero personnages.\n");
		return;
	}

	while(Hero != NULL)
	{
		printf("\n");
		printf("Personnage principal : \n");
		printf("[%d vies] \n", Hero->health);
		printf("[%d points d'attaque] \n", Hero->attack);
		printf("[%d d'abcisse] \n", Hero->x_pos);
		printf("[%d d'ordonnée] \n", Hero->y_pos);
		printf("[%d point d'expériences] \n", Hero->current_xp);

		if(Hero->weapon_type == 1){
			printf("[Canon à bulles] \n");
		}else{
			printf("[Fusil] \n");

		}
		Hero = Hero->next;
	}

	printf("\n");
}

// --------------------------------------------------------------------- //


List delete_end_list(List li)
{
	if(is_empty_list(li))
		return new_character();

	//Si la liste n'a qu'un seul élément
	if(li->next == NULL)
	{
		free(li);
		li = NULL;

		return new_character();
	}

	Hero *temp = li;
	Hero *before = li;

	while(temp->next != NULL)
	{
		before = temp;
		temp = temp->next;
	}

	before->next = NULL;

	free(temp);
	temp = NULL;

	return li;
}

// --------------------------------------------------------------------- //

List delete_start_list(List li)
{
	Hero *element;

	element = malloc(sizeof(*element));

	if(element == NULL)
	{
		fprintf(stderr, "Erreur : probleme allocation dynamique.\n");
		exit(EXIT_FAILURE);
	}

	if(is_empty_list(li))
		return new_character();

	element = li->next;

	free(li);
	li = NULL;

	return element;
}

// --------------------------------------------------------------------- //

List clear_list(List li)
{
	if(is_empty_list(li))
		return new_character();

	while(li != NULL)
		li = delete_start_list(li);

	return li;
}




// --------------------------------------------------------------------- //


List create_Hero(List li)
{
	Hero *element;

	element = malloc(sizeof(*element));

	if(element == NULL)
	{
		printf("Erreur\n");
		exit(EXIT_FAILURE);
	}

	printf("Nombre de vies : ");
	scanf("%d", &element->health);
	printf("Nombre de points d'attaque : ");
	scanf("%d", &element->attack);
	printf("Position x  : ");
	scanf("%d", &element->x_pos);
	printf("Position y : ");
	scanf("%d", &element->y_pos);
	printf("Nombre d'xp' : ");
	scanf("%d", &element->current_xp);
	printf("Type d'arme (1 : canon à bulle ||  2 : fusil) : ");
	scanf("%d", &element->weapon_type);
	element->next = NULL;

	if(is_empty_list(li))
		return element;

	Hero *temp;
	temp = li;

	while(temp->next != NULL)
		temp = temp->next;

	temp->next = element;

	return li;
}
/*
	element->health = 10;
	element->attack = 15;
	element->x_pos = 315;
	element->y_pos = 225;
	element->current_xp = 0;
	element->weapon_type = 1; //1 = canon à bulles || 2 = fusil// enum?
*/

// ------------------------------------------------------------------ //

 
/*void HeroCharacter(int direction) {
    int r = 50;

     glPushMatrix();
      while (direction--) {
       glRotatef(90, 0, 0, -1);
      } // permet de changer d'angle lorsqu'on change de direction
    glColor3f(1, 1, 0);
    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(0, 0);
    int detail = 30;
   // int startPoint = 15 * sin(tick / 15);
    for (int i = 0; i < detail; i++) {
        double deg = (i * (360 - 2 * 1) / detail) + 0;
        double x = r * cos(deg * 3.14 / 180);
        double y = r * sin(deg * 3.14 / 180);
        glVertex2f(x, y);
    }
    glEnd();
    glPopMatrix();
}
*/
// ------------------------------------------------------------------ //

void HeroCharacter(int direction) {
    //int startPoint = 15 * sin(tick / 15);

    glPushMatrix();

	int ratiox = HEIGHT/mY;
	int ratioy = WIDTH/mX;
     
	glBegin(GL_QUADS);
	glColor3f(0,0,0);

	glVertex2d(0,0);
	glVertex2d(ratiox,0);
	glVertex2d(ratiox,ratioy);
	glVertex2d(0, ratioy);

	//drawSquare(1.0,1.0,1.0,0,0,0);

    glEnd();
    glPopMatrix();

}
// ------------------------------------------------------------------ //

void updatePos(int direction) {
    const int SPEED = 62;
    switch (direction) {
    case 0:
        if (xPos < xwcMax || wrapAround)
            xPos += SPEED;
        break;
    case 1:
        if (yPos > ywcMin || wrapAround)
            yPos -= SPEED;
        break;
    case 2:
        if (xPos > xwcMin || wrapAround)
            xPos -= SPEED;
        break;
    case 3:
        if (yPos < ywcMax + 2 || wrapAround)
            yPos += SPEED;
        break;
    };
   
}
*/